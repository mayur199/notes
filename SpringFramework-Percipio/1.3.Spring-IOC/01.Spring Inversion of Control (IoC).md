### **Spring Inversion of Control (IoC)**

#### **Introduction**

In traditional Java development, objects are created and managed manually using the `new` keyword. For example:

```java
class Car {
    Engine engine = new Engine();
}
```

Here, `Car` is directly dependent on `Engine`, making the code  **tightly coupled** . If we change the `Engine` implementation, we must modify `Car` as well.

üëâ **Problem:** As applications grow, managing object creation and dependencies manually becomes difficult.

---

### **What is Inversion of Control (IoC)?**

**Inversion of Control (IoC)** is a design principle where the control of object creation and dependency management is **given to a container** (like Spring), instead of being handled manually in the code.

In Spring, the  **IoC Container** :

1. **Creates objects (beans)**
2. **Manages dependencies between objects**
3. **Configures beans based on metadata (`@Component`, XML, Java Config, etc.)**
4. **Manages bean lifecycle**

With IoC, instead of manually creating dependencies, we let the **Spring Container** handle it.

---

### **Implementing IoC in Spring**

#### **1. Using `ApplicationContext` to Create and Manage Beans**

Spring provides an `ApplicationContext`, which acts as the IoC container to manage objects.

üìå **Example:**

```java
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.stereotype.Component;

// Step 1: Define a Spring Bean
@Component  // Marks this class as a managed Spring Bean
class Engine {
    public Engine() {
        System.out.println("Engine Created!");
    }
  
    void start() {
        System.out.println("Engine Started!");
    }
}

// Step 2: Another Bean that depends on Engine
@Component
class Car {
    private Engine engine;

    // Step 3: Spring will inject the Engine Bean automatically
    public Car(Engine engine) {
        this.engine = engine;
        System.out.println("Car Created!");
    }

    void drive() {
        engine.start();
        System.out.println("Car is Running...");
    }
}

// Step 4: Configure Spring IoC Container
public class IoCDemo {
    public static void main(String[] args) {
        // Create the ApplicationContext (Spring IoC Container)
        ApplicationContext context = new AnnotationConfigApplicationContext("com.example");

        // Get the Car bean from the IoC container
        Car car = context.getBean(Car.class);
        car.drive();  // Use the bean
    }
}
```

### **Output:**

```
Engine Created!
Car Created!
Engine Started!
Car is Running...
```

‚úÖ **Spring IoC container automatically created and injected `Engine` into `Car` without `new Engine()`!**

---

### **2. Implementing Different Configuration Methods for Flexible Bean Definitions**

Spring allows defining beans in multiple ways:

#### **1Ô∏è‚É£ Annotation-Based Configuration (`@Component`)**

* As shown earlier, we can use `@Component` to mark a class as a bean.
* Use `@ComponentScan` or specify package in `ApplicationContext`.

#### **2Ô∏è‚É£ Java-Based Configuration (`@Bean`)**

* We can define beans manually in a configuration class.

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
class AppConfig {
    @Bean
    public Engine engine() {
        return new Engine();
    }

    @Bean
    public Car car() {
        return new Car(engine());
    }
}
```

* Use `ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);`

#### **3Ô∏è‚É£ XML-Based Configuration (Older Approach)**

* Define beans in `applicationContext.xml` using `<bean>` tags.

```xml
<bean id="engine" class="com.example.Engine"/>
<bean id="car" class="com.example.Car">
    <constructor-arg ref="engine"/>
</bean>
```

* Load context: `ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");`

---

### **3. Linking Beans Automatically using `@Autowired`**

Instead of manually injecting dependencies, use `@Autowired` to let Spring  **automatically link beans** .

üìå **Example using `@Autowired`**

```java
@Component
class Car {
    @Autowired  // Spring automatically injects the Engine bean
    private Engine engine;

    void drive() {
        engine.start();
        System.out.println("Car is Running...");
    }
}
```

### **How does `@Autowired` work?**

* Spring **searches for a matching bean** (by type) and injects it automatically.
* If multiple beans of the same type exist, use `@Qualifier("beanName")` to specify which one to use.

---

### **Summary**

‚úÖ **Inversion of Control (IoC) helps in:**

1. **Reducing manual object creation** (`new` keyword is not needed).
2. **Managing dependencies automatically** (using `@Autowired` or configuration classes).
3. **Allowing flexibility** (use annotations, Java config, or XML).
4. **Making applications loosely coupled and easy to maintain.**
